![1602378888927](C:\Users\JK Zhu\AppData\Roaming\Typora\typora-user-images\1602378888927.png)

​																      java虚拟机运行时数据区

阴影部分为由所有线程共享的数据区，程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭。

白底为线程隔离的数据区

## 第一章



### 程序计数器

​	看着当前线程所执行的字节码的行号指示器

### java虚拟机栈

​	线程私有，生命周期与线程相同，`JVMS`描述的是java方法执行的线程内存模型；每个方法被执行的时候，java虚拟机都会创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。==局部变量表存储了编译器可知的java基本数据类型、对象引用==。真正的对象实例存放在java堆中。这些数据类型在局部变量表中以局部变量槽来表示，其中64为位的long和double类型都会占用两个槽slot。其余只占用一个，虚拟机具体用多大的内存空间来实现一个槽具体由虚拟机自行决定。

### 本地方法栈

​	本地方法栈与虚拟机栈所发挥的作用非常相似，区别是虚拟机栈为虚拟机执行java方法（也就是字节码服务），而本地方法栈则是为虚拟机使用到的本地(Native)方法服务。

​	Native方法就是一个java调用非java代码得接口，一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。

### java 堆

​	此内存区域得唯一作用就是存放对象实例。逃逸分析技术、栈上分配、标量替换等优化手段使得对象不一定在java堆上创建。java堆是垃圾收集器管理得内存区域。因此也被成称为GC堆。从分配内存得角度看，所有得线程共享得java堆中可以划分出多个线程私有的分配缓冲区（TLAB），以提高对象分配得效率。

#### [逃逸分析概述](https://blog.csdn.net/ym15229994318ym/article/details/106543378)

- 如何将堆上的对象分配到栈，需要使用逃逸分析手段。

- 这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。

- 通过逃逸分析，Java Hotspot编译器**能够分析出一个新的对象的引用的使用范围**从而决定是否要将这个对象分配到堆上。

- 逃逸分析的基本行为就是分析对象动态作用域：①：当一个对象在**方法中被定义后**，对象**只在方法内部使用，则认为没有发生逃逸，将堆上的对象分配到栈上，随着方法执行结束，栈空间就被移除**。②：当一个对象在方法中被定义后，它**被外部方法所引用，则认为发生逃逸**。例如作为调用参数传递到其他地方中。

  如何快速判断对象是否发生逃逸，就看new的对象是否有可能会在方法外被使用。
  `结论：开发中能使用局部变量的，就不要使用在方法外定义。`

	### 方法区

​	方法区与java堆一样，是各个线程共享的，方法区是一种逻辑概念。它用于存储已被虚拟机加载的类型信息、常量、==静态变量==、即时编译器编译后的代码缓存等数据。别名是非堆。垃圾收集行为在这个区域的确是比较少出现的。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载。在JDK7以前，HotSpot使用永久代来实现方法区，==JDK8之后，类变量则会随着Class对象一起存放在java堆中。这时候“类变量在方法区中”就完全是一种逻辑表达了。==

	##### 类变量与实例变量

​	类变量是用static关键字修饰的变量，可以通过类名直接调用，类变量存储在方法区中；实例变量是没有使用static关键字修饰的变量，需要在创建一个具体实例才可以获取，实例变量在对象实例化时跟随实例对象一起存储在java堆中。

------

## 第二章



### 对象的创建

​	在java虚拟机中，当java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须执行相应的类加载过程。类加载检查通过后，虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成之后便可完全确定。

​	在虚拟机中频繁的创建对象在并发情况下不是线程安全的。解决这个问题有两种可选方案：

+ 对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性。
+ 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在java堆中预先分配一小块内存，称为本地线程分配缓冲TLAB,哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只用本地缓冲区用完了，分配新的缓存区时才需要同步锁定。

​	对象存在对象头，里面存储着对象所属类的信息以及哈希码，GC分代年龄等信息，都是jvm进行的必要设置。

### 对象的内存布局

​	对象在堆内存中的存储布局可以划分为三个部分：对象头，实例数据和对齐填充。

​	对象头包含两类信息：

	+	用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等
	+	类型指针，即对象指向它的类型元数据的指针，java虚拟机通过这个指针来确定该对象是哪个类的实例。不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息不一定要经过对象本身。

当对象是数组时，对象头中还必须要有一块用于记录数组长度的数据。

​	实例数据部分是对象真正存储的有效信息

​	对象的第三部分是对齐填充，这并不是必然存在的。

### 对象访问定位

​	java程序会根据栈上的引用去操作堆上的具体数据。那么引用如何去定位、访问到堆中的具体位置呢？这是由java虚拟机的实现而定的。主流的有两种方式：句柄和直接指针。

+ 如果使用句柄访问的话，java堆中将可能会划分出一块内存来作为句柄池，引用中存储的就是对象的句柄地址，而句柄中包含了==对象示例数据与类型数据各自具体的地址信息==。
+ 如果使用直接指针访问的话，java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，引用中存储的==直接就是对象地址，如果只访问对象本身的话，就不需要多一次间接访问的开销==。

## 第三章

​	只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。

### 判断对象是否存活

​	垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还活着，哪些已经死去。

#### 引用计数法算法

​	在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器就减一；任何时刻计数器为零的对象就是不可能再被使用的。单纯的引用技术很难解决对象之间相互循环引用的问题。

#### 可达性分析

​	这个算法的基本思路就是通过一系列称为GCRoots的根对象作为起始节点集，从这些结点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”如果某个对象到GCRoots间没有任何引用链相连，或者用图论的话来说就是从GCRoots到这个对象不可达时，则证明此对象不可能再被引用。

​	GCRoots的对象包括一下几种：

+ 在虚拟机栈中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
+ 在方法去中类静态属性引用的对象，譬如Java类的引用类型静态变量。
+ 在方法区中常量引用的对象，譬如字符串常量池里的引用。
+ 在本地方法栈中JNI(即通常所说的native)引用的对象。
+ java虚拟机内部的引用，如基本数据类型对应的Class对象。
+ 所有被同步锁持有的对象
+ 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

### 是否回收对象

​	在可达性分析中被判定为不可达的对象，也不是非死不可的，要真正回收一个对象，至少要经过两次标记过程：如果此对象与GCRoots之间没有引用链，那它将会第一次标记，随后进行一次筛选，筛选的条件说此对象是否有必要执行finalize()方法。假如对象没有重写这个方法，活此方法已经被调用过，则不需要执行，此时会回收对象。如果执行finalize方法，那么该对象会被放在一个F-Queue队列之中，如果finalize函数体中存在此对象与引用链上的任何一个对象建立关联，则对象不会被回收。finalize方法只能被执行一次。

### 垃圾收集算法

​	从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”和“追踪式垃圾收集”

75-89重点129-137

 **Minor GC ，Full GC 触发条件**

Minor GC触发条件：当Eden区满时，触发Minor GC。

Full GC触发条件：

（1）调用System.gc时，系统建议执行Full GC，但是不必然执行

（2）老年代空间不足

（3）方法去空间不足

（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存

（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

[idea配置查看垃圾回收日志](https://blog.csdn.net/qq_30055391/article/details/84840467)

## 第四章 虚拟机性能监控、故障处理工具

### 	虚拟机进程状况工具（jps）

​		利用jps命令可以列出正在运行的虚拟机进程。jps的常用选项如下表

| 选项 | 作用                                             |
| ---- | ------------------------------------------------ |
| -q   | 只输出LVMID,省略主类的名称                       |
| -m   | 输出虚拟机进程启动时传递给主类main()函数的参数   |
| -l   | 输出主类的全名，如果进程时是jar包，则输出jar路径 |
| -v   | 输出虚拟机启动时jvm参数                          |

	### 	虚拟机统计信息监视工具（jstat）

​		jstat是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行工具。

​		[jstat命令选项以及各参数表示内容](https://blog.csdn.net/zhaozheng7758/article/details/8623549)

	### 	java配置信息工具（jinfo）
	
	### 	java内存映像工具（jmap）

​		jmap的作用不仅仅是为了获取堆转储快照，它还可以查询finalize执行队列、java堆和方法去的详细信息，如空间使用率、当前用的是哪种收集器等。

| 选项           | 作用                                                         |
| -------------- | ------------------------------------------------------------ |
| -dump          | 生成java堆转储快照，（jmap -dump:format=b,file=(文件名.bin)）;可以用jhat来查看这个文件 |
| -finalizerinfo | 显示在F-Queue中Finalizer线程执行finalize方法的对象           |
| -heap          | 显示java堆详细信息                                           |
| -histo         | 显示堆中对象统计信息，可以存储为txt文件（jmap -histo 2364 > obj.txt） |
|                |                                                              |
|                |                                                              |

 ### 		jhat虚拟机堆转储快照分析工具

​		jhat命令与jmap搭配使用，来分析jmap生成的堆转储快照。	

###  	java堆栈跟踪工具(jstack)

​		jstack命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。线程快照是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的目的通常是定位线程出现较长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等。可以用getAllStackTrance()来获取所有的线程StackTranceElement对象。

	### 	基于服务型代理的调试工具（JHSDB）
	
	### 	Java监视与管理控制台（JConsole）

### 可视化故障处理工具

	### 	java监视与管理控制台（Jconsole）

​	命令行jconsole

### 多合一故障处理工具（VisualVM）		

​	命令行jvisualvm

### 可持续在线的监控工具（jmc）

### 补充

​	javap -v class文件名可反编译分析class文件

​	![1603594562284](C:\Users\JK Zhu\AppData\Roaming\Typora\typora-user-images\1603594562284.png)

------



## 第五章 调优案例分析与实战

	###  	编译时间和类加载时间的优化
	
		+  编译时间主要是即时编译将部分代码的字节码转化为机器码，当程序一直运行时可以加快程序的运行时间，刚开始会占用一点时间。一般不建议关闭即时编译
	
	+ 类加载优化可以在类加载时不进行字节码验证，通过-Xverify:none来设置

###     调整内存设置控制垃圾收集频率

​	通过jvisualvm来查看系统的垃圾收集情况，如果垃圾收集次数过多，则可以增大内存，减少垃圾收集频率。结合垃圾收集日志来进行具体操作减少垃圾收集时间。

​	可以设置以下几个参数要求虚拟机生成gc日志：-XX:PrintGCTimeStamps(打印GC停顿时间)、-XX:PrintGCDetails（打印GC详细信息）-verbose:gc(打印GC信息，输出内容已被前一个参数包括，可以不写)、-Xloggc:gc.log

## 第七章

​	本章主要介绍虚拟机如何加载class文件，以及class文件中的信息在进入虚拟机之后会发生什么变化。由于本章需要讲述如何加载class文件，因此避免不了对class文件的解析以及各种转换操作，所以会涉及到上一章提到的专用术语，例如全限定名

### 类加载机制

​	java虚拟机将==描述类的数据==从class文件中==加载==到内存，并对数据进行==校验、转换解析和初始化==，最终形成可以被虚拟机直接使用的java类型，这一过程被称为虚拟机的类加载机制。

### 	类加载地过程

​	加载---》验证---》准备---》解析---》初始化---》使用---》卸载

​	加载、验证、准备、初始化、卸载这五个阶段的顺序是确定的，类加载必须按照这种顺序开始，这种顺序只是适用于开始，随着类加载的不断进行，各个阶段可能会交叉进行，会存在相互调用的情况。

#### 加载

​	加载是类加载的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：

+ 通过一个类的全限定名来获取定义此类的==二进制字节流==
+ 将这个字节流所代表的==静态存储结构==转化为方法区的==运行时数据结构==
+ 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区的这个类的各种数据的访问入口

这一阶段非常灵活，给开发者的提供了一个自由发挥的舞台。由于没有严格指明应该从哪获取类的二进制字节流以及如何获取，因此开发者可以采用不同的获取途径以及获取方式来实现类的加载过程。

#### 验证

​	验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身安全。上一节讲述了Class除了由java文件编译产生之外还有很多产生方式，这些方式并不能够确保Class文件是安全的。

​	验证阶段会完成四个阶段的校验动作：文件格式验证，元数据验证，字节码验证和符号引用验证。

#### 准备

​	准备阶段是正式为类中定义的变量（静态变量）分配内存并设置变量初始值的过程。从概念上讲，这些内存都分配在方法区中。

​	在准备阶段，有两点需要注意：

​	1）准备阶段只对类变量进行内存分配和初始化操作，对于实例变量不进行任何操作。

​	2）在对变量赋初始值时，没有final修饰符的类变量统一赋0值，有final修饰符的类变量赋程序定义的具体值

#### 解析

​	解析阶段是java虚拟机将常量池内的符号引用解析为直接引用，这里要理解符号引用和直接引用的含义。

​	解析阶段包括：类或接口解析，字段解析，方法解析（不包括接口方法），接口方法解析

#### 初始化

​	直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权转交给应用程序。在准备阶段对于没有final修饰的类变量，虚拟机默认给它们赋予了0值，在初始化阶段，虚拟机根据具体的程序代码为这些变量或者静态代码块赋值。

​	初始化阶段可以表达为：初始化阶段就是执行类构造器<clinit>()方法的过程。

​	<clinit>()方法是javac编译器的产物。<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在之后的变量，静态代码块可以赋值，但是不能访问。

### 类加载器

#### 类与类加载器

​	对于任意一个类，都必须由加载它的类加载器和这个类本身一起确立其在java虚拟机中的唯一性。

​	java一直保持着三层类加载器和双亲委派的类加载架构。

#### 三个类加载器

​	1）启动类加载器（负责加载存放在JAVA_HOME\lib目录或者被-Xbootchclasspath参数所指定的路径中存放的企且能被java虚拟机识别的类库）

​	2）扩展类加载器（JDK9被平台类加载器取代，负责加载JAVA_HOME\lib\ext目录）

​	3）应用程序类加载器（负责加载ClassPath上所有的库）

#### 双亲委派模型

​	当一个类加载器收到一个类加载请求时，它自己不会首先去加载这个类，而是将这个类委派给父类加载器加载，每一层的类加载器都是如此，因此最终都会传递到启动类加载器进行处理，当父类无法完成这个请求，便会反馈给子类，此时子类加载器会尝试去加载这个类。

Q:为什么要使用双亲委派模型

A:如果不使用双亲委派模型，都由各个类自己去加载的话，如果用户也编写了一个java.lang.Obejct类并放在程序的ClassPath中，那系统会出现多个不同的Object类，应用程序将会混乱

#### 模块下的类加载器

​	JDK9中仍然维持着三层类加载器和双亲委派的架构，但类加载的委派关系发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器前，要先判断该类是否能够归属到某一个系统模块中，如果可以就要优先委派给负责那个模块的加载器完成加载。

### 第八章 虚拟机字节码执行引擎






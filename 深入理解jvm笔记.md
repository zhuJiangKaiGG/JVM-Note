![1602378888927](https://raw.githubusercontent.com/zhuJiangKaiGG/PicGo/master/img/1602378888927.png)

​																      java虚拟机运行时数据区

阴影部分为由所有线程共享的数据区，程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭。

白底为线程隔离的数据区

## 第一章



### 程序计数器

​	看着当前线程所执行的字节码的行号指示器

### java虚拟机栈

​	线程私有，生命周期与线程相同，`JVMS`描述的是java方法执行的线程内存模型；每个方法被执行的时候，java虚拟机都会创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。==局部变量表存储了编译器可知的java基本数据类型、对象引用==。真正的对象实例存放在java堆中。这些数据类型在局部变量表中以局部变量槽来表示，其中64为位的long和double类型都会占用两个槽slot。其余只占用一个，虚拟机具体用多大的内存空间来实现一个槽具体由虚拟机自行决定。

### 本地方法栈

​	本地方法栈与虚拟机栈所发挥的作用非常相似，区别是虚拟机栈为虚拟机执行java方法（也就是字节码服务），而本地方法栈则是为虚拟机使用到的本地(Native)方法服务。

​	Native方法就是一个java调用非java代码得接口，一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。

### java 堆

​	此内存区域得唯一作用就是存放对象实例。逃逸分析技术、栈上分配、标量替换等优化手段使得对象不一定在java堆上创建。java堆是垃圾收集器管理得内存区域。因此也被成称为GC堆。从分配内存得角度看，所有得线程共享得java堆中可以划分出多个线程私有的分配缓冲区（TLAB），以提高对象分配得效率。

#### [逃逸分析概述](https://blog.csdn.net/ym15229994318ym/article/details/106543378)

- 如何将堆上的对象分配到栈，需要使用逃逸分析手段。

- 这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。

- 通过逃逸分析，Java Hotspot编译器**能够分析出一个新的对象的引用的使用范围**从而决定是否要将这个对象分配到堆上。

- 逃逸分析的基本行为就是分析对象动态作用域：①：当一个对象在**方法中被定义后**，对象**只在方法内部使用，则认为没有发生逃逸，将堆上的对象分配到栈上，随着方法执行结束，栈空间就被移除**。②：当一个对象在方法中被定义后，它**被外部方法所引用，则认为发生逃逸**。例如作为调用参数传递到其他地方中。

  如何快速判断对象是否发生逃逸，就看new的对象是否有可能会在方法外被使用。
  `结论：开发中能使用局部变量的，就不要使用在方法外定义。`

	### 方法区

​	方法区与java堆一样，是各个线程共享的，方法区是一种逻辑概念。它用于存储已被虚拟机加载的类型信息、常量、==静态变量==、即时编译器编译后的代码缓存等数据。别名是非堆。垃圾收集行为在这个区域的确是比较少出现的。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载。在JDK7以前，HotSpot使用永久代来实现方法区，==JDK8之后，类变量则会随着Class对象一起存放在java堆中。这时候“类变量在方法区中”就完全是一种逻辑表达了。==

	##### 类变量与实例变量

​	类变量是用static关键字修饰的变量，可以通过类名直接调用，类变量存储在方法区中；实例变量是没有使用static关键字修饰的变量，需要在创建一个具体实例才可以获取，实例变量在对象实例化时跟随实例对象一起存储在java堆中。

------

## 第二章



### 对象的创建

​	在java虚拟机中，当java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须执行相应的类加载过程。类加载检查通过后，虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成之后便可完全确定。

​	在虚拟机中频繁的创建对象在并发情况下不是线程安全的。解决这个问题有两种可选方案：

+ 对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性。
+ 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在java堆中预先分配一小块内存，称为本地线程分配缓冲TLAB,哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只用本地缓冲区用完了，分配新的缓存区时才需要同步锁定。

​	对象存在对象头，里面存储着对象所属类的信息以及哈希码，GC分代年龄等信息，都是jvm进行的必要设置。

### 对象的内存布局

​	对象在堆内存中的存储布局可以划分为三个部分：对象头，实例数据和对齐填充。

​	对象头包含两类信息：

	+	用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等
	+	类型指针，即对象指向它的类型元数据的指针，java虚拟机通过这个指针来确定该对象是哪个类的实例。不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息不一定要经过对象本身。

当对象是数组时，对象头中还必须要有一块用于记录数组长度的数据。

​	实例数据部分是对象真正存储的有效信息

​	对象的第三部分是对齐填充，这并不是必然存在的。

### 对象访问定位

​	java程序会根据栈上的引用去操作堆上的具体数据。那么引用如何去定位、访问到堆中的具体位置呢？这是由java虚拟机的实现而定的。主流的有两种方式：句柄和直接指针。

+ 如果使用句柄访问的话，java堆中将可能会划分出一块内存来作为句柄池，引用中存储的就是对象的句柄地址，而句柄中包含了==对象示例数据与类型数据各自具体的地址信息==。
+ 如果使用直接指针访问的话，java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，引用中存储的==直接就是对象地址，如果只访问对象本身的话，就不需要多一次间接访问的开销==。

## 第三章

​	只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。

### 判断对象是否存活

​	垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还活着，哪些已经死去。

#### 引用计数法算法

​	在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器就减一；任何时刻计数器为零的对象就是不可能再被使用的。单纯的引用技术很难解决对象之间相互循环引用的问题。

#### 可达性分析

​	这个算法的基本思路就是通过一系列称为GCRoots的根对象作为起始节点集，从这些结点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”如果某个对象到GCRoots间没有任何引用链相连，或者用图论的话来说就是从GCRoots到这个对象不可达时，则证明此对象不可能再被引用。

​	GCRoots的对象包括一下几种：

+ 在虚拟机栈中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
+ 在方法去中类静态属性引用的对象，譬如Java类的引用类型静态变量。
+ 在方法区中常量引用的对象，譬如字符串常量池里的引用。
+ 在本地方法栈中JNI(即通常所说的native)引用的对象。
+ java虚拟机内部的引用，如基本数据类型对应的Class对象。
+ 所有被同步锁持有的对象
+ 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

### 是否回收对象

​	在可达性分析中被判定为不可达的对象，也不是非死不可的，要真正回收一个对象，至少要经过两次标记过程：如果此对象与GCRoots之间没有引用链，那它将会第一次标记，随后进行一次筛选，筛选的条件说此对象是否有必要执行finalize()方法。假如对象没有重写这个方法，活此方法已经被调用过，则不需要执行，此时会回收对象。如果执行finalize方法，那么该对象会被放在一个F-Queue队列之中，如果finalize函数体中存在此对象与引用链上的任何一个对象建立关联，则对象不会被回收。finalize方法只能被执行一次。

### 垃圾收集算法

​	从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”和“追踪式垃圾收集”

75-89重点129-137

 **Minor GC ，Full GC 触发条件**

Minor GC触发条件：当Eden区满时，触发Minor GC。

Full GC触发条件：

（1）调用System.gc时，系统建议执行Full GC，但是不必然执行

（2）老年代空间不足

（3）方法去空间不足

（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存

（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

[idea配置查看垃圾回收日志](https://blog.csdn.net/qq_30055391/article/details/84840467)

## 第四章 虚拟机性能监控、故障处理工具

### 	虚拟机进程状况工具（jps）

​		利用jps命令可以列出正在运行的虚拟机进程。jps的常用选项如下表

| 选项 | 作用                                             |
| ---- | ------------------------------------------------ |
| -q   | 只输出LVMID,省略主类的名称                       |
| -m   | 输出虚拟机进程启动时传递给主类main()函数的参数   |
| -l   | 输出主类的全名，如果进程时是jar包，则输出jar路径 |
| -v   | 输出虚拟机启动时jvm参数                          |

	### 	虚拟机统计信息监视工具（jstat）

​		jstat是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行工具。

​		[jstat命令选项以及各参数表示内容](https://blog.csdn.net/zhaozheng7758/article/details/8623549)

	### 	java配置信息工具（jinfo）
	
	### 	java内存映像工具（jmap）

​		jmap的作用不仅仅是为了获取堆转储快照，它还可以查询finalize执行队列、java堆和方法去的详细信息，如空间使用率、当前用的是哪种收集器等。

| 选项           | 作用                                                         |
| -------------- | ------------------------------------------------------------ |
| -dump          | 生成java堆转储快照，（jmap -dump:format=b,file=(文件名.bin)）;可以用jhat来查看这个文件 |
| -finalizerinfo | 显示在F-Queue中Finalizer线程执行finalize方法的对象           |
| -heap          | 显示java堆详细信息                                           |
| -histo         | 显示堆中对象统计信息，可以存储为txt文件（jmap -histo 2364 > obj.txt） |
|                |                                                              |
|                |                                                              |

 ### 		jhat虚拟机堆转储快照分析工具

​		jhat命令与jmap搭配使用，来分析jmap生成的堆转储快照。	

###  	java堆栈跟踪工具(jstack)

​		jstack命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。线程快照是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的目的通常是定位线程出现较长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等。可以用getAllStackTrance()来获取所有的线程StackTranceElement对象。

	### 	基于服务型代理的调试工具（JHSDB）
	
	### 	Java监视与管理控制台（JConsole）

### 可视化故障处理工具

	### 	java监视与管理控制台（Jconsole）

​	命令行jconsole

### 多合一故障处理工具（VisualVM）		

​	命令行jvisualvm

### 可持续在线的监控工具（jmc）

### 补充

​	javap -v class文件名可反编译分析class文件

​	![1603594562284](C:\Users\JK Zhu\AppData\Roaming\Typora\typora-user-images\1603594562284.png)

------



## 第五章 调优案例分析与实战

###  	编译时间和类加载时间的优化

+ 编译时间主要是即时编译将部分代码的字节码转化为机器码，当程序一直运行时可以加快程序的运行时间，刚开始会占用一点时间。一般不建议关闭即时编译

+ 类加载优化可以在类加载时不进行字节码验证，通过-Xverify:none来设置

###     调整内存设置控制垃圾收集频率

​	通过jvisualvm来查看系统的垃圾收集情况，如果垃圾收集次数过多，则可以增大内存，减少垃圾收集频率。结合垃圾收集日志来进行具体操作减少垃圾收集时间。

​	可以设置以下几个参数要求虚拟机生成gc日志：-XX:PrintGCTimeStamps(打印GC停顿时间)、-XX:PrintGCDetails（打印GC详细信息）-verbose:gc(打印GC信息，输出内容已被前一个参数包括，可以不写)、-

------



## 第六章 类文件结构

------

​	这章的内容在后续章节中会经常用到，所以一些重要概念要了解清楚

### 概述

​	计算机只认识“0”和“1”，因此以前的程序代码都得编译成机器码计算机才能执行，随着技术的发展，将程序代码编译成字节码，并在虚拟机上运行字节码的出现使得越来越多的程序语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。

### class类文件结构

​	class文件是一组以8字节（一字节等于8位）为基础单位的==二进制流==，各个数据项目严格按照顺序紧凑地排列在文件之中。

​	class文件格式采用一种类似于c语言结构体的伪结构体来存储数据，这种伪结构中只有两种数据类型：“无符号数”与“表”

+ 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表一个字节、两个字节、四个字节、八个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者UTF-8编码构成字符串值。
+ 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，表的命名习惯性的以“_info”结尾。

#### 魔数与class文件的版本

​	每个class文件的开头四个字节（0xCAFEBABY）被称为魔数，它的唯一作用是确定这个文件是否能被虚拟机接受的class文件。紧接着魔数的四个字节是存储class文件的版本号，第五位、六位为次版本号，一般默认为0，第七八位为主版本号。随着Java版本的更新，其对应的主版本号也会递增，高版本的虚拟机可以执行低版本的class文件，相反低版本的虚拟机不能执行高版本的class文件。

#### 常量池

​	紧接着主、次版本号之后的常量池入口，常量池可以比喻为class文件里的资源仓库，它是class文件结构中与其他项目关联最多的数据，通常也是占用class文件空间最大的数据项目之一，另外，它还是class文件中第一个出现的表类型数据项目。

​	常量池的入口需要放置一项u2类型的数据，用来统计常量池的容量。常量池中主要存放两大类常量：字面量和符号引用。字面量比较接近java语言层面的常量概念，如文本字符串、被声明为final的常量值等。符号引用主要包括下面几类常量：

+ 被模块导出或者开放的包
+ 类和接口的全限定名
+ 字段的名称和描述符
+ 方法的名称和描述符
+ 方法句柄和方法类型
+ 动态调用点和动态常量

#### 访问标志

​	在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final；

#### 类索引、父类索引与接口索引集合

​	类索引和父类索引都是一个u2类型的数据，而接口索引集和是一组u2类型的数据的集合，class文件中由这三项来确定该类型的继承关系。

#### 字段表集合

​	字段表用于描述接口或者类中声明的变量包括类变量以及实例变量但不包括在方法内部声明的局部变量。

## 第七章

​	本章主要介绍虚拟机如何加载class文件，以及class文件中的信息在进入虚拟机之后会发生什么变化。由于本章需要讲述如何加载class文件，因此避免不了对class文件的解析以及各种转换操作，所以会涉及到上一章提到的专用术语，例如全限定名

### 类加载机制

​	java虚拟机将==描述类的数据==从class文件中==加载==到内存，并对数据进行==校验、转换解析和初始化==，最终形成可以被虚拟机直接使用的java类型，这一过程被称为虚拟机的类加载机制。

### 	类加载地过程

​	加载---》验证---》准备---》解析---》初始化---》使用---》卸载

​	加载、验证、准备、初始化、卸载这五个阶段的顺序是确定的，类加载必须按照这种顺序开始，这种顺序只是适用于开始，随着类加载的不断进行，各个阶段可能会交叉进行，会存在相互调用的情况。

#### 加载

​	加载是类加载的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：

+ 通过一个类的全限定名来获取定义此类的==二进制字节流==
+ 将这个字节流所代表的==静态存储结构==转化为方法区的==运行时数据结构==
+ 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区的这个类的各种数据的访问入口

这一阶段非常灵活，给开发者的提供了一个自由发挥的舞台。由于没有严格指明应该从哪获取类的二进制字节流以及如何获取，因此开发者可以采用不同的获取途径以及获取方式来实现类的加载过程。

#### 验证

​	验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身安全。上一节讲述了Class除了由java文件编译产生之外还有很多产生方式，这些方式并不能够确保Class文件是安全的。

​	验证阶段会完成四个阶段的校验动作：文件格式验证，元数据验证，字节码验证和符号引用验证。

#### 准备

​	准备阶段是正式为类中定义的变量（静态变量）分配内存并设置变量初始值的过程。从概念上讲，这些内存都分配在方法区中。

​	在准备阶段，有两点需要注意：

​	1）准备阶段只对类变量进行内存分配和初始化操作，对于实例变量不进行任何操作。

​	2）在对变量赋初始值时，没有final修饰符的类变量统一赋0值，有final修饰符的类变量赋程序定义的具体值

#### 解析

​	解析阶段是java虚拟机将常量池内的符号引用解析为直接引用，这里要理解符号引用和直接引用的含义。

​	解析阶段包括：类或接口解析，字段解析，方法解析（不包括接口方法），接口方法解析

#### 初始化

​	直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权转交给应用程序。在准备阶段对于没有final修饰的类变量，虚拟机默认给它们赋予了0值，在初始化阶段，虚拟机根据具体的程序代码为这些变量或者静态代码块赋值。

​	初始化阶段可以表达为：初始化阶段就是执行类构造器<clinit>()方法的过程。

​	<clinit>()方法是javac编译器的产物。<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在之后的变量，静态代码块可以赋值，但是不能访问。

### 类加载器

#### 类与类加载器

​	对于任意一个类，都必须由加载它的类加载器和这个类本身一起确立其在java虚拟机中的唯一性。

​	java一直保持着三层类加载器和双亲委派的类加载架构。

#### 三个类加载器

​	1）启动类加载器（负责加载存放在JAVA_HOME\lib目录或者被-Xbootchclasspath参数所指定的路径中存放的企且能被java虚拟机识别的类库）

​	2）扩展类加载器（JDK9被平台类加载器取代，负责加载JAVA_HOME\lib\ext目录）

​	3）应用程序类加载器（负责加载ClassPath上所有的库）

#### 双亲委派模型

​	当一个类加载器收到一个类加载请求时，它自己不会首先去加载这个类，而是将这个类委派给父类加载器加载，每一层的类加载器都是如此，因此最终都会传递到启动类加载器进行处理，当父类无法完成这个请求，便会反馈给子类，此时子类加载器会尝试去加载这个类。

Q:为什么要使用双亲委派模型

A:如果不使用双亲委派模型，都由各个类自己去加载的话，如果用户也编写了一个java.lang.Obejct类并放在程序的ClassPath中，那系统会出现多个不同的Object类，应用程序将会混乱

#### 模块下的类加载器

​	JDK9中仍然维持着三层类加载器和双亲委派的架构，但类加载的委派关系发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器前，要先判断该类是否能够归属到某一个系统模块中，如果可以就要优先委派给负责那个模块的加载器完成加载。

------



## 第八章 虚拟机字节码执行引擎

​	本章分析了虚拟机在执行字节码文件时，如何选择执行哪个方法，如何执行方法内的字节码，以及执行代码时涉及的内存结构。

### 概述

​	物理机和虚拟机都可以执行代码，物理机执行机器码，java虚拟机可以执行字节码，当然java虚拟机也可以将字节码转化为机器码（即时编译）。所有的java虚拟机的执行引擎输入、输出都是一样的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果。

#### 	Q : java虚拟机是如何将java文件转化为字节码再转化为机器码？

​	javac(java编译器)将源代码（.java）转化为字节码（.class）之后，其实要运行程序，有两种选择。一种是使用 Java 解释器解释执行字节码，另一种则是使用 JIT 编译器将字节码转化为本地机器代码。

​	这两种方式的区别在于，前者启动速度快但运行速度慢，而后者启动速度慢但运行速度快。至于为什么会这样，其原因很简单。因为解释器不需要像 JIT 编译器一样，将所有字节码都转化为机器码，自然就少去了优化的时间。而当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。所以在实际情况中，为了运行速度以及效率，我们通常采用两者相结合的方式进行 Java 代码的编译执行。现在大多数是解释执行与编译执行相结合，当一段代码执行次数达到一定大小时，这段代码就会判定为热代码交给即时编译器即时编译成本地代码（机器码）。

### 运行时栈帧结构

​	java虚拟机以方法作为最基本的执行单元，“栈帧”则是用于支持虚拟机进行方法调用和方法执行的数据结构。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。在编译java源程序时，栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入方法表的Code属性中（如例8-1）。换句话说，一个栈帧需要分配多少内存，并不会收到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。

​	例8-1：在启动类中编写如下代码，在命令行中输入javap -v class文件名

```java
    public static void main(String[] args) {
        int a = 100;
        int b = 200;
        int c = 300;
        int i = (a + b) * c;
    }
```

生成的反编译文件如下图：stack表示操作数栈大小为2，用了5个局部变量槽，方法参数个数为1

![1603805444611](https://raw.githubusercontent.com/zhuJiangKaiGG/PicGo/master/img/1603805444611.png)

### 局部变量表

​	局部变量表是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。在java程序被编译成class文件时，就在方法的code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量（局部变量槽的数量）。

​	局部变量表容量的最小单位是局部变量槽。

​	java中占用不超过32为存储空间的数据类型有：boolean, byte, char, short, int, ==float==, reference, returnAddress八种。

​	java语言中明确的64位的数据类型只有long,double两种。对于64位的数据，java虚拟机会以高位对齐的方式为其分配==两个连续的变量槽空间==。这种做法与“long和double”的非原子性协定中允许把一次long和double数据类型读写分割位两次32位读写的方式有点类似。由于局部变量表属于线程私有，所以不用担心读写两个连续的变量槽这个操作是否是原子性的而导致线程不安全的问题。同时对于两个相邻的共同存放一个64位变量的局部变量槽，虚拟机不允许单独对其中一个进行访问，

​	在执行实例方法时，局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以用this来访问这个隐含的参数。因此在平时编码中，许多实例方法中都可以通过this.方法名/属性名 来获取当前实例中的方法或者定义的属性。

​	局部变量一定要赋初始值（类变量不需要赋初始值，虚拟机在类加载的准备阶段会默认赋予0值），如果一个局部变量没有赋初始值，则无法使用这个局部变量。

### 操作数栈

​	操作数栈也被称为操作栈，它是一个后入先出的栈。同局部变量表一样，在编译器，其最大深度也被写进了Code属性的max_stacks数据项中。32位数据类型所占的栈容量为1，64位数据所占的栈容量位2。

​	当一个方法刚刚开始的时候，这个方法的操作数栈为空，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈的操作。

### 动态连接

​	Class文件的常量池中存有的大量的符号引用，一部分会在类加载的解析阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外一部分将在每一次运行期转化为直接引用，这部分称为动态连接。

### 方法返回地址

​	方法开始执行后只有两种方式退出这个方法：

+ 第一种是执行引擎遇到任意一个方法返回的字节码指令（遇到return指令或者程序正常运行完结束）；
+ 第二种是方法在执行过程遇到异常，并且这个异常没有在方法体内得到正常的处理（例如没有使用try catch捕获异常等），如果本方法的异常表种没有搜索到匹配异常的异常处理器，就会导致方法退出，这种方式的退出称为“异常调用完成”。一个方法使用异常完成出口的方式退出是不会给它的上层返回任何值得。

例如以下代码:

```java
package com.test.demo.test;

/**
 * @Author :zjk
 * @Date :Create in 10:11 2020-10-30
 * @Description
 **/
public class My_Test {
    public static int exceptionOne(){
        int i = 10 / 0;
        return 1;
    }
    public static void getReturn(){
        int i = exceptionOne();
        System.out.println(i);
    }
    public static void main(String[] args) {
        getReturn();
    }
}

```

​	由于除数不能为0，所以此段代码会抛出异常，但是在方法体内没有进行异常处理，因此这属于第二种方法结束得方式，因此，getReturn方法获取不到返回值。运行结果如下

```shell
Exception in thread "main" java.lang.ArithmeticException: / by zero
	at com.test.demo.test.My_Test.exceptionOne(My_Test.java:10)
	at com.test.demo.test.My_Test.getReturn(My_Test.java:14)
	at com.test.demo.test.My_Test.main(My_Test.java:18)

Process finished with exit code 1
```

​	当我们添加异常处理时，方法得异常表种就能匹配到相应得异常处理器，因属于第一种结束方法。修改代码及运行结果如下

```java
package com.test.demo.test;

/**
 * @Author :zjk
 * @Date :Create in 10:11 2020-10-30
 * @Description
 **/
public class My_Test {
    public static int exceptionOne(){
        try {
            int i = 10 / 0;
        } catch (Exception e) {
            System.out.println("除数不能为0");
        }
        return 1;
    }
    public static void getReturn(){
        int i = exceptionOne();
        System.out.println(i);
    }
    public static void main(String[] args) {
        getReturn();
    }
}

```

​	运行结果：

```
除数不能为0
1
```

### 方法调用

​	方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法）。这一小节讲述了在方法重载以及重写时，虚拟机如何选择合适的方法运行。对于方法重载和重写的理解有很大帮助。

	#### 解析

​	在java语言中符合“编译器可知，运行期不可变”这个要求的方法，主要有静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法都不可能通过继承或其他方式重写出其他版本，因此他们适合在类加载阶段进行解析。

​	java虚拟机支持以下5条方法调用字节码指令，分别是：

+ invokestatic 调用静态方法
+ invokespecial 用于调用实例构造器<init>()方法、私有方法和父类中的方法。
+ invokevirtual 用于调用所有的虚方法
+ invokeinterface 用于调用接口方法，会在运行时再确定一个实现该接口的对象。
+ invokedynamic 先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。

====	只要能被invokestatic和invokespecial指令调用的方法（其中被invokevirtual调用的final修饰的方法），都可以在类加载阶段中确定唯一的版本（在类加载阶段将符号引用解析为直接引用）。

#### 分派

​	这一小节结合书本代码仔细阅读，对理解重载有很大的帮助

​	静态分派和动态分派是选择相应的方法。

### 基于栈的字节码解释执行引擎

#### 解释执行

​	java虚拟机以前是通过解释器来执行字节码文件的，但现在虚拟机中 包含了即时编译器，此时要选择对字节码进行解释执行还是编译执行就得让虚拟机自行决定了（前面也讲过，对于一些频繁执行得代码，当执行次数达到一定量时虚拟机会采用即时编译将字节码编译成机器码）。

​	对源码得编译阶段在第十章得10.2阶段有详细介绍。

### 基于栈的指令集与基于寄存器的指令集

​	javac编译器输出的字节码指令流，基本上是一种基于栈的指令集架构，字节码指令流里面的指令大多数都是零地址指令，他们依赖操作数栈进行工作。

​	两种不同指令集的优缺点：

​	基于栈：

​	优点：方便移植，因为寄存器架构是由硬件直接提供

​	缺点：执行速度慢

### 基于栈的解释器执行过程

​	书上的例子解释的很清楚，建议详细阅读

​	字节码指令：

 + aload 从局部变量表的局部变量槽相应位置装载一个对象引用到操作数栈顶

 + iload、lload、fload、dload用来装载非对象引用，依次对应int、long、float、double类型

 + ibpush是将单字节的整数类型（-128~127）入栈，sipush是将整数范围为-32768~32767时推入操作数栈顶，当int取值-2147483648~2147483647时，JVM采用ldc指令将常量压入栈中

 + istore是将栈顶的元素取出并存放到具体的（如istore_1就是第一个）局部变量槽

   ------

   

## 第九章类加载与执行子系统的案例与实战

------



## 第十章 前端编译与优化

------

## 第十一章 后端编译与优化

### 概述

​	后端编译与优化可以理解为运行期编译与优化

### 即时编译器

​	目前主流的Java虚拟机在程序最初运行时，都是采用解释器执行的，在运行过程中，虚拟机发现一段热点代码时，会调用即时编译器将这段代码编译成机器码，以此来提高热点代码的执行效率。学习了本节，我们可以解决以下几个问题：

+ 为何HopSpot虚拟机要使用解释器与即时编译器共存的架构
+ 为何HotSpot要实现两个（或三个）不同的即时编译器
+ 程序何时使用解释器执行，何时使用即时编译器执行
+ 哪些代码会被编译成本地代码，如何编译成本地代码
+ 如何从外部观察到即时编译器的编译过程和编译结果

#### 解释器与编译器

​	解释器和即时编译器两者各有优势：当程序需要快速启动和执行时，解释器可以首先发挥作用，省去编译时间，立即运行。当程序运行时，随着时间，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间损耗，提升运行速度。同时解释器对内存空间要求不高，当内存空间有限制时，可以选用解释器执行。

​	编译器在优化代码出错时，会采用逆优化退回解释状态继续由解释器执行。

​	HotSpot虚拟机内置了三个即时编译器，其中两个存在已久，分别是客户端编译器（C1）和服务端编译器(C2)，还有一个是JDK10之后出现的Graal编译器，还处在测试阶段。

​	用户可以自己设置虚拟机的运行模式。采用-Xint参数可以强制虚拟机只用解释器运行，采用参数-Xcomp强制虚拟机优先采用编译器运行，此时解释器仍然需要在编译无法进行的情况下介入执行过程。

​	为了程序启动响应速度与运行效率之间达到最佳平衡，虚拟机采用分层编译。不同层次可能混合使用，因此同一段热点代码会被编译多次。

#### 编译对象与触发条件

​	热点代码主要包括两部分：被多次调用的方法，被多次执行的循环体。两种类型的热点代码都是编译整个方法，而不是代码块。

​	判断哪些代码为热点代码主要有两种方式：

+ 基于采样的热点探测：这种方法是虚拟机会周期性的检查各个线程的调用栈顶，如果发现某个方法经常出现在栈顶，那这个方法就是热点方法。这种方法实现比较简单，但当遇到线程阻塞或别的外界因素影响时误差较大。
+ 基于计数器的热点探测：这种方法时虚拟机为每个方法（甚至是代码块）建立计数器（方法计数器和回边计数器，其中方法计数器是记录一段时间的相对值，在特定的时间没有达到阈值会自动半衰减，回边计数器是记录方法中循环体的执行次数，记录的是绝对值，不会进行半衰减），统计方法的执行次数，当次数超过了指定的阈值则被判定为热点方法，阈值可以自己设定。这种方法实现比较复杂，但准确性高。

​	当虚拟机在运行一点代码时，它会先去寻找这个代码快有没有存在编译的版本，有的话采用编译器执行，没有的话采用解释器执行，如果此段代码刚被判断为热点代码，虚拟机还是会先选择解释器执行，同时即时编译器会编译这段代码，当编译完成时，下一次运行这段代码就会采用即时编译器执行。

#### 编译过程

​	对于不同的编译器，编译过程有所差别。客户端编译器是一个相对简单的三段式编译器，关注的是局部优化，放弃了很多耗时较长的全局优化。服务端编译器是一个能容忍很高优化复杂度的高级编译器。而且它相对于客户端编译输出的代码质量有很多的提高，可以大幅度减少本地代码的执行时间，从而抵消掉额外的编译时间开销。

#### 提前编译

​	提前编译有两条明显的分支：一条是做与传统的C、C++编译器类似的，在程序运行之前把程序代码编译成机器码的静态翻译工作；另外一条是把原本即时编译器在运行时要做的编译工作提前做好并保存下来，下次运行到这些代码时直接把它加载进来使用。提前编译因为没有执行时间和资源限制的压力，能够毫无顾忌地使用重负载的优化手段。

​	即时编译相对于提前编译地优点：

+ 性能分析制导优化
+ 激进预测性优化
+ 链接时优化

### 编译器优化技术

​	四种代表性地优化技术

#### 方法内联

​	方法内联式编译器最重要的优化手段，内联被称为优化之母，因为除了消除方法掉用的成本之外，它更重要的意义是为其他优化手段建立良好的基础。方法内联简单理解就是将目标方法的代码原封不动的“赋值”到发起调用的方法中，避免发生真实的方法调动。如下例子

```java
public static void foo(Object obj){
    if (obj != null){
        System.out.println("do something");
    }
}
public static void testInline(String[] args){
    Object obj = null;
    foo(obj);
}
```

​	上面这段代码如果没有方法内联优化是无法发现"Dead Code"的存在。因此也不会进行任何优化，这也说明了方法内联是其他优化的重要基础。

​	但并不是所有的方法都能够进行方法内联优化，因为对于一个虚方法（java语言中默认的实例方法是虚方法，除了final修饰的）,编译器静态内联时很难确定应该使用哪个版本的方法，往往需要程序的上下文环境，要在程序运行到这一行时才能确定。因此编译器会设置“逃生门”，如果加载了导致继承关系发生变化的新类，编译器就应该放弃已经编译了的代码，转而退回到解释器执行。

#### 逃逸分析

​	逃逸分析并不是直接优化代码的手段，而是为其他优化措施提供依据的分析技术。

​	逃逸分析的原理是：分析对动态作用域，当一个对象在方法里面被定义后，它可能作为参数被外部方法访问，这种称为方法逃逸，还可能被别的线程访问，这种称为线程逃逸；从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。如果能证明一个对象不逃逸或者只发生方法逃逸，则可以采用以下方法优化。

+ 栈上分配：在虚拟机中对象往往都是分配在java堆中，同时垃圾收集主要是发生在Java堆上。当一个对象不逃逸或者只是方法逃逸时，可以将此对象分配在栈上，对象所占用的内存空间就可以随着栈帧出栈而自动销毁，这可以使得垃圾收集子系统的压力下降很多。栈上分配不支持线程逃逸。
+ 标量替换：若一个数据无法分解成更小的数据来表示（例如int、long等数值类型和reference）那这些数据就可以称为标量。相对的如果一个数据可以继续分解则称为聚合量，对象就属于聚合量。假如逃逸分析确定一个对象不能被方法外部访问，那么程序真正执行的时候可以==不去创建这个对象而改为直接创建它的若干个被这个方法使用的成员变量来代替==
+ 同步消除：如果逃逸分析能够确定一个对象不会发生线程逃逸，无法被其他线程访问，那么这个变量的读写肯定不会由竞争，可以消除对这个变量实施的同步措施。

逃逸分析目前还不是很成熟，且计算成本很高。

#### 公共子表达式消除

​	如果一个表达式前面已经计算过，且没有发生过任何变化，则当前没必要再花时间对其重新进行计算，可以直接引用前面计算过的值。

#### 数组边界检查消除

### 实战：深入理解Graal编译器

------



## 第十二章 java内存模型与线程

### 概述

​	让计算机同时去处理几件事情，不仅是因为计算机的运算能力强大，还有一个很重要的原因：计算机的运算速度与它的存储和通信子系统的速度差距很大，大量的时间都花费在磁盘的读写、网络通信或者数据库访问上。因此如果只执行一个线程的话，计算机处理器大部分时间都处在等待状态。

​	衡量一个服务的好坏，每秒事务处理数（TPS）是一个很重要的指标，表示一秒内服务端平均能响应的请求数。

### 硬件的效率与一致性

​	由于计算机处理器运行速度数存储设备的运行速度有着较大的差距，因此现代计算机都引入了一个高速缓存来作为处理器与内存之间的缓冲。同时引入告诉缓存也带来了一个问题：缓存一致性。

### Java内存模型

​	java定义了一种java内存模型来屏蔽各种==硬件和操作系统的内存访问差异==

#### 主内存与工作内存

​	java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这也的底层细节。此处的变量指的是线程共有的变量，方法的局部变量和参数属于线程私有的。

​	java内存模型中规定所有变量都存储在主内存中。每条线程有自己的工作内存。不同的线程之间无法直接访问对方工作内存中的变量，县城就变量传递需要通过主内存来实现，为了获得更好的运行速度，虚拟机会将线程的工作内存存放在寄存器或者高速缓存中，因为程序运行时主要访问的时工作内存，

#### 内存间交互操作

​	关于主内存和工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节，java内存模型定义了8种操作来完成。java虚拟机实现时必须保证下面提及的每一种操作都是原子性的。

+ lock
+ unlock
+ read
+ load
+ use
+ assign
+ store
+ write

#### 对于volatile型变量的特殊规则

​	关键字volatile是Java虚拟机提供的==最轻量级==的同步机制。

​	当一个变量被定义成volatile之后，它具备两项特性：

+ 保证此变量对所有线程的可见性，这里的可见性是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主存来完成。比如，线程A修改了一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成之后再对主内存进行读取操作，新变量的值才会在线程B可见。虽然volatile时对所有线程可见的，但不意味着基于volatile==变量的运算==在并发下是线程安全的。因为Java里面的运算操作符并不是原子性的，所以如果运算中需要依赖volatile变量的当前值，则有可能会产生线程安全问题，因为volatile只保证变量的值在此时是正确的，如果在进行运算时改变了这个值，则取出来的那个值就变成了过期数据。
+ 禁止指令重排序优化，普通的变量仅仅会保证在该方法的执行过程中所以依赖赋值结果的地方都能得到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。双锁检测的单例模式就是一个防止指令重排序的例子。

​	volatile变量读操作的性能消耗与普通变量没有什么区别，但是写操作则可能会慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不会发生乱序执行。大多数场景下volatile的总开销都比锁来的要更低。具体选择哪种同步方式需要根据具体的场景来确定。

#### 针对long和double型变量的特殊规则

#### 原子性、可见性与有序性

​	Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性者三个特征来建立的。

### Java与线程

------

​	

## 第十三章 线程安全与锁优化

